# -*- coding: utf-8 -*-
"""Copy of CIS_545_Fall_2022_HW4_STUDENT_VERSION_Rui_Kan.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BAf89Oo1kjR6kSUcx6aPQ8x9_uLU-Mfg

# CIS 545 Homework 4: Machine Learning

*Due Date: **18th November 2022 at 10:00PM EST**, 100 points total (= 89 autograded + 11 manually graded).*

**PLEASE READ THE FAQ as you do this assignment!** It's pinned on Ed and we TAs work really hard to keep it updated with everything you might need to know or anything we might have failed to specify. Writing these HWs and test cases gets tricky since students always end up implementing solutions that we did not anticipate and thus could not have prepared the grader correctly for.

# Libraries and Setup Jargon
Run the following cells to set up the notebook.

Please make sure you enter your **8 digit Penn ID** in the  student ID field below.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install -i https://test.pypi.org/simple/ penn-grader==0.5.0
# from penngrader.grader import *
# 
# #PLEASE ENSURE YOUR PENN-ID IS ENTERED CORRECTLY. IF NOT, THE AUTOGRADER WON'T KNOW WHO 
# #TO ASSIGN POINTS TO YOU IN OUR BACKEND
# 
# STUDENT_ID = 15599572       # YOUR PENN-ID GOES HERE AS AN INTEGER

# Commented out IPython magic to ensure Python compatibility.
# %%writefile config.yaml
# 
# grader_api_url: 'https://wyv616tp17.execute-api.us-east-1.amazonaws.com/default/Grader'
# grader_api_key: 'Kd32fl3g3p917iM0zwjiO23Bitj4PO9ga4LektOa'

grader = PennGrader('config.yaml', 'CIS_5450_Fall22_HW4', STUDENT_ID, STUDENT_ID)

# Sklearn and Pandas Setup
import json
import glob
import pandas as pd
import numpy as np
import datetime as dt
import re
import os
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import cm
from google.colab import drive
from sklearn.model_selection import train_test_split

!apt update

"""# **Part I:** Preprocessing and Modeling in `scikit-learn` (68 points)

## **1.1** Data Loading and Preprocessing

### **1.1.1** Read

We are using one CSV for this homework, `Airbnb_Open_Data.csv` from a Kaggle dataset. The dataset contains a column called price which corresponds to the prices of each Airbnb listing in New York.

To get the data in here:
1. Go to this [Kaggle link](https://www.kaggle.com/datasets/arianazmoudeh/airbnbopendata) and create a Kaggle account (unless you already have an account)
2. Go to Account and click on "Create New API Token" to get the API key in the form of a json file `kaggle.json`
3. Upload the `kaggle.json` file to the default location in your Google Drive (Please **DO NOT** upload the json file into any _specific_ folder as it will be difficult for us to debug issues if you deviate from these instructions!).

This can be helpful for your project if you decide to use Kaggle.
"""

# Run this cell to mount your drive (you will be prompted to sign in)
from google.colab import drive
drive.mount('/content/drive')

!pip install kaggle

# Create the kaggle directory and read the uploaded kaggle.json file
# (NOTE: Do NOT run this cell more than once unless restarting kernel)
!mkdir ~/.kaggle

# Read the uploaded kaggle.json file
!cp /content/drive/MyDrive/kaggle.json ~/.kaggle/

# Download dataset
!!kaggle datasets download -d arianazmoudeh/airbnbopendata

# Unzip folder in Colab content folder
!unzip /content/airbnbopendata.zip

"""Load `Airbnb_Open_Data.csv` as `df_airbnb`."""

# TO-DO: Read the csv file and save it to a dataframe called `df_airbnb`
df_airbnb = pd.read_csv('Airbnb_Open_Data.csv')

# Check out the first five rows
df_airbnb.head()

"""### **1.1.2** Check Nulls

Drop the columns in `df_airbnb` which have greater than 50% Null Values. 
"""

# TO-DO: Drop the columns which have greater than 50% null values. 
perc = 50.0
min_count =  int(((100-perc)/100)*df_airbnb.shape[0] + 1)
df_airbnb = df_airbnb.dropna( axis=1, 
                thresh=min_count)

#Grader Cell (1 point)
grader.grade(test_case_id = 'check_nulls', answer = df_airbnb.head())

"""### **1.1.3** Drop Duplicates

Store the number of duplicate rows present in the dataframe into a variable named: `total_duplicates`. Then drop all these duplicate rows from `df_airbnb`.
"""

#TO-DO: Store the number of duplicate rows in total_duplicates
total_duplicates = sum(df_airbnb.duplicated())
total_duplicates

#TO-DO: Drop the duplicate rows
df_airbnb = df_airbnb[~df_airbnb.duplicated()]

# Grader Cell (2 points)
grader.grade(test_case_id = 'drop_duplicates', answer = (df_airbnb.shape,total_duplicates))

"""## **1.2** EDA

Exploratory Data Analysis (EDA) is an approach to analyzing data sets to summarize their main characteristics, often with visual methods. A statistical model can be used or not, but primarily EDA is for seeing what the data can tell us beyond the formal modeling or hypothesis testing task.

### 1.2.0 Cleaning Column Names

#### (a) Remove spaces

Some of the column names in the dataframe are upper case whereas some are lower case. 

Your **1st task** is to make all column names lower case.

Next, a number of columns have spaces in them - For Example: `Country Code`, `Neighbourhood Group` etc. 

Your **2nd task** is to clean all these column names by replacing all the " " (spaces) with "_". \\
Therefore after you do these two tasks `Country Code` should become `country_code`, `Neighbourhood Group` should become `neighbourhood_group` and so on.
"""

#TO-DO: Change the column names to lower case and replace the " " with "_"
df_airbnb = df_airbnb.rename(columns=str.lower)
df_airbnb.columns = df_airbnb.columns.str.replace(' ', '_')

"""#### (b) Rename Columns

The `neighbourhood_group` column represents the different boroughs in New York. The `review_rate_number` represents the rating of the airbnb listing from a scale of 1 to 5. The `calculated_host_listings_count` represents the total no. of airbnb listings associated with a particular host.

Our task is to rename these 3 columns in `df_airbnb`.

You should rename these columns are follows:

Rename:
- `neighbourhood_group` to `borough`,
- `review_rate_number` to `rating` , and 
- `calculated_host_listings_count` to `total_host_listings`
"""

#TO-DO: renames the 3 columns mentioned in the question
df_airbnb.rename(columns = {'neighbourhood_group':'borough', 'review_rate_number':'rating',
                              'calculated_host_listings_count':'total_host_listings'}, inplace = True)

#Grader cell (3 points)
grader.grade(test_case_id = 'cleaning_columns', answer = (df_airbnb.columns))

"""### 1.2.1 Tidying Up

Upon inspection, we see that both the `country` column and the `country_code` column only have one unique value. Thus, we would like to drop these columns as it will not help in analysis or modelling. Your task for this section is to drop the `country` and `country_code` columns from the dataframe.
"""

df_airbnb

# TO-DO: Drop 'country' and 'country_code' columns
df_airbnb = df_airbnb.drop(columns=['country', 'country_code'])

"""There are some other columns which are of no use to us. Drop the following columns: `host_id, id, name, host_name, last_review`



"""

# TO-DO: Drop 'id','name','host_name','host_id','last_review' columns
df_airbnb = df_airbnb.drop(columns=['host_id', 'id', 'name', 'host_name', 'last_review'])

#Grader Cell (1 point)
grader.grade(test_case_id = 'tidy_up', answer = (df_airbnb.columns))

"""### 1.2.2 Cleaning Price and Service Fee Columns

The `price` and `service_fee` columns are of type `object` and have '$\$$' sign and commas in them. For Example: $\$$1,000. We would like to clean up the `price` and `service_fee` columns so that the columns now are of type **`float`** and have no '$\$$' sign or commas. So, $\$$1,000 would become `1000.0`

**Note: If a price or service_fee row value is NaN, let it remain as NaN**
"""

df_airbnb.dtypes

# TO-DO: Convert 'price' column to float
df_airbnb['price'] = df_airbnb['price'].replace('[\$,]', '', regex=True).astype(float)

# TO-DO: Convert 'service_fee' column to float
df_airbnb['service_fee'] = df_airbnb['service_fee'].replace('[\$,]', '', regex=True).astype(float)

#Grader (4 points)
grader.grade(test_case_id = 'clean_price_service_fee', answer = df_airbnb[:10000])

"""### 1.2.3 Reviews Per Month

The `reviews_per_month` column has NaN values in it. NaN in this column represents that there were no reviews for that airbnb listing.

Think of a way to fill in the NaN values in this column given the above information.
"""

# TO-DO: Fill in the NaN values in 'reviews_per_month'
df_airbnb[['reviews_per_month']] = df_airbnb[['reviews_per_month']].fillna(0)

df_airbnb.reviews_per_month

#Grader (2 points)
grader.grade(test_case_id = 'fill_reviews_per_month', answer = df_airbnb[:10000])

"""### 1.2.4 Clean up Borough Column

Each row in the `borough` column can be one of the following 5 values: `Manhattan, Brooklyn, Queens, Bronx, Staten Island` 

But, if you inspect the `borough` column, you'll notice a couple rows with incorrectly spelled names. Your task is to change these incorrectly spelled names to the correct borough name. For example, an incorrect name could be `brookln`, and you should change this value to `Brooklyn`.

Then, create a Pandas series `borough_counts` that shows the number of AirBnB listings (i.e. number of rows) for each of the 5 boroughs. Call this series `borough_counts`.

***Hint:*** Look at documentation of .unique() and .value_counts() and see how to obtain the unique values in a column and their respective counts

"""

df_airbnb.borough.unique()

# TO-DO: Fix the incorrect borough names and store the counts in 'borough_counts'
df_airbnb['borough'] = df_airbnb['borough'].str.replace('brookln','Brooklyn')
df_airbnb['borough'] = df_airbnb['borough'].str.replace('manhatan','Manhattan')

borough_counts = df_airbnb.borough.value_counts()

#Grader (2 point)
grader.grade(test_case_id = 'clean_borough', answer = borough_counts)

"""### 1.2.5 Drop NAs

After the pre-processing we have done above, the total no. of null values in each column should be relatively low compared to the overall size of the dataframe. Your next step is to remove all NA values from the `df_airbnb` dataframe.

"""

# TO-DO: Drop all NA values
df_airbnb = df_airbnb.dropna()

#Grader (1 point)
grader.grade(test_case_id = 'drop_na', answer = df_airbnb.shape)

"""### 1.2.6 Average Prices of Listings by Neighbourhood and Borough

####(a) Top Neighbourhoods by Average Price

`Task`:
For each borough find the top 5 neighbourhoods with the highest average price of listings.

You should return a dataframe called `neighbourhood_prices_top_5` with the following columns:
- `'borough'`
- `'neighbourhood'`
- `'avg_price'`

The number of rows in this dataframe should be **25**, this is because there are 5 boroughs and you have been asked to find the top 5 neighbourhoods by average price in each of these boroughs.

**NOTE**: When returning the `neighbourhood_prices_top_5` dataframe make sure to:
- sort the `'borough'` column in **ascending order** (alphabetically)
- sort the `'avg_price'` column in **descending Order** (highest to lowest)
"""

# TO-DO: For each borough find the top 5 neighbourhoods with the highest average price of listings.

neighbourhood_prices = df_airbnb.groupby(['borough', 'neighbourhood']).mean().reset_index()
neighbourhood_prices = neighbourhood_prices[['borough', 'neighbourhood', 'price']]
neighbourhood_prices_top_5= neighbourhood_prices.groupby(['borough']).apply(lambda x: x.sort_values(['price'],ascending = False)).reset_index(drop = True)
neighbourhood_prices_top_5 = neighbourhood_prices_top_5.groupby(['borough']).head(5)
neighbourhood_prices_top_5.rename(columns = {'price': 'avg_price'}, inplace = True)

#Grader (5 points)
grader.grade(test_case_id = 'neighbourhood_prices', answer = neighbourhood_prices_top_5)

"""#### (b) Graph

*Manually graded*: **5 points**

Using `neighbourhood_prices_top_5`, plot a bar chart with y axis as `avg_price` and x axis as `neighbourhood`. The x axis should contain 25 bars (5 bars for each borough), and the bars should represent the average prices in those neighbourhoods. 

Make sure that:
- The graph has an appropriate title along with axis labels
- Bars are color coded by `borough`:
  - You must include the corresponding legend/color key for each `borough`
- Your graph is clearly legible and there should not be overlapping text

**REMINDER:** Do NOT save the plot as a separate image file! You must ensure that the plot is displayed in your Colab notebook before submission. If you do not hit "Restart and Run All" to ensure this before your final submission, we _**will deduct -3 points from your final score.**_


"""

# TO-DO: Plot the graph (5 points)
plt.figure(figsize=(14,7))
sns.countplot(x ='neighbourhood', hue = 'borough', data = neighbourhood_prices_top_5, 
              dodge = False).set(title='Neighbourhood Prices',xlabel='Neighbourhood',ylabel='Average Price')
sns.set(rc={'figure.figsize':(11,8)})
# Show the plot
plt.show()

"""### **1.2.7** Correlation of Feature Variables

1.   List item

---



> Indented block

---




2.   List item



With multiple features, it can be somewhat exhausting to do bivariate analysis on every possible pair of features. While you certainly should, your first instinct should be to check for the correlation between features since certain models (e.g. Linear Regression) won't work well if we have strong multicollinearity.

_**Isolating Numerics from Categorical Features**_

Before anything else, it may help to create groups of the numeric vs. categorical variables.

Your task is to split the `df_airbnb` dataframe into 2 dataframes:

1. `numerics_df`: This dataframe contains all numerical columns from `df_airbnb`

2. `categorical_df`: This dataframe contains all categorical columns from `df_airbnb`
"""

df_airbnb.dtypes

# TO-DO: Form 'numerics_df' and 'categorical_df'
numerics_df = df_airbnb.select_dtypes(include='float64')
categorical_df = df_airbnb.select_dtypes(include='object')

#Grader (2 points)
grader.grade(test_case_id = 'check_correlation', answer = [numerics_df.columns, categorical_df.columns])

"""_**Correlation Heatmap**_ \\
*Manually graded*: **2 points**

Next, create a correlation matrix using `numerics_df` and call it `corr_matrix`. Using the correlation matrix, generate a correlation heatmap for these numeric features. Look into how to use the `seaborn` library to do this _(imported as `sns` above)_.

Like the plot in 1.2.6, we are going to be rather strict about the details and presentation when we manually grade your correlation heatmap (out of **3 points**). Make sure your correlation heatmap meets the following criteria:
- Ensure that your heatmap is appropriately sized: all feature labels should be visible on both the $x$-axis and $y$-axis
- Use the `RdBu` color map to ensure that negative correlations are red and positive correlations are blue
- Standardize the color scale so that -1 takes the darkest red color, 0 is totally white, and +1 takes the darkest blue color 
"""

# TO-DO: Plot correlation heatmap (3 points)
sns.set(rc={'figure.figsize':(15,13)})
heatmap = sns.heatmap(numerics_df.corr(), cmap="RdBu", vmin=-1, center=0, vmax=1, square=True, linewidths=.5, cbar_kws={"shrink": .5}, annot=True)
plt.title("Correlation Heatmap")
heatmap

"""## **1.3** Feature Engineering

Feature engineering is the process of applying domain knowledge to extract features from raw data via data mining techniques. These features can be used to improve the performance of machine learning algorithms.

### **1.3.1** Changing service_fee to categorical

We see from the Correlation Matrix, that the `service_fee` variable is highly correlated with `price`. In Section 1.4 we will be doing a regression task with `price` as the dependent variable. We believe that `service_fee` is a good predictor for price.

Note that since `service_fee` is directly calculated from the price, `service_fee` is highly correlated with `price`. Ideally we would want to not use `service_fee`, and instead collect other features. But in this HW, we will try to reduce the information contained in the `service_fee` column. We want to change this variable into a categorical variable which would decrease its correlation. This way, we could use this new categorical variable in our modeling. 

Create a new column called `service_fee_factor` which can contain two values (0,1) that respectively represent low and high service fee in the following manner:

`service_fee_factor = 0, if service_fee < 50th percentile`

`service_fee_factor = 1, if service_fee >= 50th percentile`

Hint: Recall that the 50th percentile is the median, and can be computed via `.median()`.

***Side Note:*** Most Hosts pay a flat service fee of 3% of the booking subtotal. The subtotal is your nightly price plus any optional fees you charge guests, like a cleaning fee, and doesn't include Airbnb fees and taxes. Thus, if we were building a price prediction model we won't have access to the service fee for new listings. Thus, it won't be preferable to include `service_fee` or `service_fee_factor` in our model. A work-around would be to first run a clustering model to predict the `service_fee_factor` using other features (excluding `price`), and then run our regression model to predict `price`.
"""

# TO-DO: Change service_fee to categorical 
median = df_airbnb.service_fee.median()
df_airbnb['service_fee_factor'] = np.where((df_airbnb['service_fee'] >= median), 1, 0)

#Grader (2 points)
grader.grade(test_case_id = 'zero_one_tuple', answer = (df_airbnb['service_fee_factor'].value_counts()[0], df_airbnb['service_fee_factor'].value_counts()[1]))

"""### **1.3.2** Proposed Ranking System for Ordinal Encoding

The `cancellation_policy` column, as the name suggests, contains information on how lenient the cancellation policy is. As such, in order to make the data useful as feature variables, we encode these policies using _Ordinal Encoding_. If a certain type of cancellation policy is strict, we want it to have a higher ranked value. Create a new column called `"cancellation_factor"` that contains these ordinal encodings (ranks).

**Clarifications**:
- To eliminate ambiguity, please rank the cancellation policy according to: `flexible < moderate < strict`
- If the cancellation policy is flexible, assign the lowest rank of 0 to it.
"""

# TO-DO: Create a new column called "cancellation_factor" that takes a ranked integer value between 0 and 2.
dict ={'flexible':0,'moderate':1,'strict':2}
df_airbnb['cancellation_factor'] = df_airbnb['cancellation_policy'].apply(lambda x : dict[x])

# Grader (2 points)
grader.grade(test_case_id = 'check_cancellation_factor', answer = list(df_airbnb['cancellation_factor'][:10000]))

"""Now that we have created a factor column for `cancellation_policy` we can drop that column


## **Don't forget to run the following cell!**
"""

df_airbnb.drop(columns=["cancellation_policy"], axis=1, inplace=True)

"""### **1.3.3** One Hot Encoding

One hot encoding is a process by which categorical variables are converted into a form that could be provided to ML algorithms to do a better job in prediction. With one-hot encoding, we convert each categorical value into a new categorical column and assign a binary value of 1 or 0 to those columns. 

One way to one-hot encode in Pandas is by using `pd.get_dummies()` . The documentation can be found [here](https://pandas.pydata.org/docs/reference/api/pandas.get_dummies.html). 

Use `pd.get_dummies()` to one hot encode the following columns: `host_identity_verified', 'borough', 'instant_bookable', 'room_type'`. Do not modify the prefix, instead use the default names that are generated by `pd.get_dummies()`.

We will be dropping the column `neighbourhood` because this column contains many different values. Since our dataframe contains other columns containing geographic information (eg. `borough`, `lat` & `long`), we can use these other columns to figure out the neighbourhood of a particular AirBnB listing.
"""

# TO-DO: Drop the `neighbourhood` column
df_airbnb = df_airbnb.drop('neighbourhood', axis = 1)

# TO-DO: One-hot encode
df_airbnb = pd.get_dummies(data=df_airbnb, columns=['host_identity_verified', 'borough', 'instant_bookable', 'room_type'])

# Grader (2 points)
grader.grade(test_case_id = 'check_one_hot_encode', answer = df_airbnb[:10000])

"""### **1.3.4** Preprocessing: Split into Features and Label

Now that we have explored and cleaned our dataset, let's prepare it for a machine learning task. In this homework, you will work with various models and attempt to predict the price of a room.

The features will be the encoded variables you've created so for from 1.3.1 - 1.3.3 AND the following other attributes: `lat`, `long`, `construction_year`, `minimum_nights`, `number_of_reviews`, `reviews_per_month`, `rating`, `total_host_listings`, `availability_365`. The label will be the `price`, indicating the price. Store these two as `features` and `prices`, respectively.
"""

# TO-DO: stores features dataframe into variable called "features"
features = df_airbnb.drop(columns = ['price', 'service_fee'])

# TO-DO: store the regression target variable into "prices"
prices = df_airbnb['price']

# Grader (2 points)
grader.grade(test_case_id = 'feature_label_split_regression', answer = (features.columns, prices.name))

"""## **1.4** Modeling (sklearn)

***Manual Grading (1 point):*** The section 1.4 has a manual grading component of *1 point*. We will be manually going through your modelling structure. There will be negative points for grave mistakes in modelling(Example: Using test data for training, not calculating the predictions on appropriate data sets, etc.)

### **1.4.1** Split Data into Train and Test

Use scikit-learn's `train_test_split` function to split data for regression into train and test sets. The split should be 80-20 meaning 80% for training and rest for testing.

Since this part concerns regression, you should carefully think about what should be our target variable?

**_IMPORTANT_: Please set the `seed` variable to 42 and then set the parameter to `random_state = seed`** and store the resulting splits as `x_train, x_test, y_train,` and `y_test`. This is necessary in order for our autograder to accurately evaluate your answer.
"""

# TO-DO: Assign appropriate value to seed and conduct 80/20 train-test split with random_state = seed
seed = 42
x_train, x_test, y_train, y_test = train_test_split(features, prices, test_size=0.2, random_state=seed)

# Grader (4 points)
grader.grade(test_case_id = 'train_test_split_regression', answer = (x_train.shape, x_test.shape, y_train.shape, y_test.shape, seed,y_test.sort_values()[:20]))

"""### **1.4.2** Regression Models

#### (a) Linear Regression (Unregularized)

Use the `LinearRegression` class in scikit-learn to perform Linear Regression. Initialize a Linear regression model named `reg` with default parameters, fit the model to the training set, and then make predictions on the testing set.

Save your predictions in an array named `y_pred`, and report your R-squared score (saved it as a variable called `score`).
"""

# TO-DO: Import required libraries
from sklearn.linear_model import LinearRegression

# TO-DO: Initialize model with default parameters and fit it on the training set
reg = LinearRegression().fit(x_train, y_train)

# TO-DO: Use the model to predict on the test set and save these predictions as `y_pred`
y_pred = reg.predict(x_test)

# TO-DO: Find the R-squared score and store the value in `score`
score = reg.score(x_test, y_test)

# Grader (5 points)
grader.grade(test_case_id = 'check_linear_reg', answer = (score, reg.coef_, reg.intercept_))

"""#### (b) Ridge Regression

Use the `Ridge` class in scikit-learn to perform $L_2$ Regularized Linear Regression. Initialize a Ridge regression model named `reg_ridge` with regularization strength `alpha = 10`, fit the model to the training set, and then make predictions on the testing set.

Report your $R^2$ score and save it as a variable called `ridge_score`.
"""

# TO-DO: Import required libraries
from sklearn.linear_model import Ridge
# TO-DO: Initialize model with alpha = 10 (keep other hyperparameters as default values) and fit it on the training set
reg_ridge = Ridge(alpha=10).fit(x_train, y_train)

# TO-DO: Use the model to predict on the test set and save these predictions as `y_pred`
y_pred = reg_ridge.predict(x_test)

# TO-DO: Find the R-squared score and store the value in `ridge_score`
ridge_score = reg_ridge.score(x_test, y_test)

# Grade (2 points)
grader.grade(test_case_id = 'check_ridge_reg', answer = (ridge_score, reg_ridge.alpha))

"""_**Exam-Style Practice Questions:**_

_(While we will NOT grade this for the purpose of the HW, it is in your best interest to take just 30-60 seconds to think about this as the CIS 5450 teaching staff may very well put something similar in the final exam!_ üòâ_)_

- What do you notice about the $R^2$ scores of the Ridge and unregularized Linear Regression above?
- If Ridge is supposed to "improve" Linear Regression, we may find it unusual if that is not happening here. Under what circumstances would we consider using Ridge over unregularized Linear Regression?
- Would you expect different results if we made `alpha` bigger ($\alpha \rightarrow \infty$)? smaller ($\alpha \rightarrow 0$)? Why or why not?

### **1.4.3** Classification Models
We are now switching into classification mode. We will be predicting whether the rating is `high` or `low`. A `high` rating is defined as one where the rating is above 2 and `low` is one where the rating is less than or equal to 2. Create a new column called ```rating_boolean``` in the dataframe which has ```1.0``` if the rating is ```high``` and ```0.0``` if the rating is ```low``` \\
We also need to redefine our features for this new task. Carefully think about which columns should be used as features and which column should be used as label. Store these as `labels` and `features` respectively.

#### (a) Creating the classification labels
Add a new column called `'rating_boolean'` to the DataFrame which is **1.0** if the rating is above 2 and **0.0** otherwise. Once you have created the column, go ahead and separate the DataFrame into `features` and `labels`, like we did in 1.3.4.

The features will be the **encoded** categories of `cancellation`, `host_identity`, `borough`,`instant_bookable`,`room_type` (from 1.3.2 - 1.3.4) **_together with_** the **continuous** attributes `['lat', 'long', 'construction_year', 'minimum_nights', 'number_of_reviews' 'reviews_per_month', 'price', 'total_host_listings', 'availability_365']`. There should therefore be a total of 23 columns.

The label will be the `rating_boolean`, indicating whether the rating is `high` or `low`. Store these two as `features` and `labels`, respectively.

- **Note 1**: Do not include highly correlated features in `features
- **Note 2**: Do not include any column which is directly related to the `labels` in the `features`. Think about why that's a bad idea as this is an extremely important consideration (we could easily examine you on this)
"""

# TO-DO: Create the "rating_boolean" target variable as a new column in df_airbnb
#        where "rating_boolean" is 1.0: if rating is above 2, 0.0: if rating is equal to or below 2
df_airbnb['rating_boolean'] = np.where((df_airbnb['rating'] > 2), 1.0, 0.0)

# TO-DO: store the columns to be used as features in a DataFrame called "features" 
features = df_airbnb.drop(columns=["service_fee", "service_fee_factor", "rating", "rating_boolean"])
# TO-DO: store the binary classification target variable as "labels"
labels = df_airbnb['rating_boolean']

grader.grade(test_case_id = 'feature_label_split_classification', answer = (features.columns,labels.name))

"""Concatenate the ```features``` and ```labels``` along ```axis = 1``` and store the result into a DataFrame called ```combined_df``` so that we can reuse this DataFrame later in Part II when we deal with Spark."""

# TO-DO: Concatenate `features` and `labels` row-wise and store in `combined_df` dataframe
combined_df = pd.concat([features, labels], axis=1)

"""#### (b) Split Data into Train and Test

Repeat 1.4.1 again but this time where our target variable is now `labels` (not "prices").

Again, we will use scikit-learn's `train_test_split` function to split the data for the classification problem into train and test sets. The split should be 80-20 meaning 80% for training and the rest for testing.

**_IMPORTANT_: Please set the `seed` variable to 42 and then set the parameter to `random_state = seed`** and store the resulting splits as `x_train, x_test, y_train,` and `y_test`.
"""

# TO-DO: Assign appropriate value to seed and conduct 80/20 train-test split with random_state = seed
seed = 42
x_train, x_test, y_train, y_test = train_test_split(features, labels, test_size=0.2, random_state=seed)

# Grader (4 points)
grader.grade(test_case_id = 'train_test_split_classification', answer = (x_train.shape, x_test.shape, y_train.shape, y_test.shape, seed,y_test.sort_values()[:20]))

"""#### (c) Logistic Regression

Fit a Logistic regression classifier on the `x_train` and `y_train` with the default hyperparameters. Calculate the accuracy of the model on the test set using the `score` method and store it in a variable named `log_acc`
"""

# TO-DO: Import required libraries
from sklearn.linear_model import LogisticRegression
# TO-DO: Initialize model with default parameters and fit it on the training set
log = LogisticRegression().fit(x_train, y_train)

# TO-DO: Use the model to predict on the test set and save these predictions as `y_pred`
y_pred = log.predict(x_test)

# TO-DO: Find the accuracy and store the value in `log_acc`
log_acc = log.score(x_test, y_test)

# Grader (2 points)
grader.grade(test_case_id = 'check_log_reg', answer = log_acc)

"""#### (d) PCA to Reduce Dimensionality

The goal of Principal Component Analysis is to reduce the number of dimensions of our features.

_**Initial PCA**_

As a first step, instantiate and fit `PCA` from scikit-learn on your training set. We are not reducing the dimensionality of our data in this step but rather trying to find what would be the ideal number of Principal Components to choose. So for this step, please keep all Principal Components.

Please remember that PCA is **not** scale-invariant! What does this imply you need to do first?
"""

# TO-DO: Impprt libraries
from sklearn.preprocessing import StandardScaler

# TO-DO: Intermediate step to address scale-invariance
features_adj = StandardScaler().fit_transform(features)

# TO-DO: Instantiate and Fit PCA
x_train_adj = StandardScaler().fit_transform(x_train)
x_test_adj = StandardScaler().fit_transform(x_test)

"""_**Cumulative Explained Variance Ratios**_

Create an array of explained variance ratios and store it into a variable called `explained_variance_ratios`. Also, calculate the _cumulative_ explained variance ratios and store that into another variable called `cum_evr`.
"""

# TO-DO: Save the explained variance ratios into variable called "explained_variance_ratios"
from sklearn.decomposition import PCA
pca = PCA()
explained_variance_ratios = pca.fit(features_adj).explained_variance_ratio_

# TO-DO: Save the CUMULATIVE explained variance ratios into variable called "cum_evr"
cum_evr = np.cumsum(explained_variance_ratios)

"""Now plot the _cumulative_ `explained_variance_ratio` against the number of components to decide the number of components you should keep. Also add a horizontal line that represents the 80% of the variance as a threshold.

As before, you should ensure that the plot follows the best practices you've developed over the past 2 plotting exercises in this HW (Labelling the axes and adding title to the plot). **This will be manually graded for 2 points** \\



_**CAUTION:** Recall that Python starts counting from 0, but this would make it very unintuitive when reading from your graph. We strongly recommend that you modify the x-axis of your graph so that the **number of components begins at 1**. Otherwise, you may risk making silly mistakes in the subsequent sections._

*Manually graded*: **2 points**
"""

# TO-DO: find optimal num components to use (n) by plotting explained variance ratio (2 points)
plt.plot(range(1, len(cum_evr)+1),cum_evr)

# Plot (1 point for correct shape)
plt.xlabel('number of components')
plt.ylabel('cumulative explained variance ratio')

# Aesthetics (1 point for title AND both axes labels)
plt.show()

# Grader (2 points)
grader.grade(test_case_id = 'check_pca_explained_variance', answer = (explained_variance_ratios, cum_evr))

"""_**Final PCA**_

Using your results above to help you decide the number of components to keep, choose a number (`n`) that explains **at least 80% of total variance** in the dataset. Then re-fit and transform your PCA on the training set using the number of components you decided.

Remember that your PCA should be trained on the training set (`x_train`) but only transformed on the test set (`x_test`).

Call your transformed set of principal components `x_test_pca` in order to submit it to the autograder.
"""

# TO-DO: Get transformed set of principal components on x_test

# 1. Refit and transform on training with parameter n (as deduced from the last step) 
pca2 = PCA(n_components= 13)
pca2.fit_transform(x_train_adj)

# 2. Transform on Testing Set and store it as `x_test_pca`
x_test_pca = pca2.transform(x_test_adj)

# Grader (2 points)
grader.grade(test_case_id = 'check_fitted_pca', answer = x_test_pca)

"""#### (e) Logistic Regression with PCA

1. Fit the logistic regression on your Final Principal Components data using your optimal `n`. Name the model `log_reg_pca`
2. Make predictions on the test set.
3. Report accuracy for the test set and call it `test_accuracy`
"""

# TO-DO: Initialize `log_reg_pca` model with default parameters and fit it on the PCA transformed training set
x_train_pca = pca2.transform(x_train_adj)

log_reg_pca = LogisticRegression().fit(x_train_pca, y_train)

# TO-DO: Use the model to predict on the PCA transformed test set and save these predictions as `y_pred`
y_pred = log_reg_pca.predict(x_test_pca)
# TO-DO: Find the accuracy and store the value in `test_accuracy`

test_accuracy = log_reg_pca.score(x_test_pca, y_test)

# Grader (4 points)
grader.grade(test_case_id = 'check_log_reg_pca', answer = (test_accuracy, log_reg_pca.n_features_in_))

"""# **Part II:** Distributed Machine Learning with Spark (32 points)

Apache Spark ML is a machine learning library that consists of common learning algorithms and utilities, including classification, regression, clustering, collaborative filtering, dimensionality reduction, and underlying optimization primitives.

**Why Spark ML?**

Standard implementations of machine learning algorithms require very powerful machines to be able to run. However, depending on high-end machines is not advantageous due to their high price and improper costs of scaling up. The idea of using distributed computing engines is to distribute the calculations to multiple low-end machines (commodity hardware) instead of a single high-end one. _This **definitely speeds up** the learning phase and allows us to create better models._

Read more about it with the python documentation **[here](https://spark.apache.org/docs/latest/ml-guide.html)**.

Run the code below to set up Spark.

**Note:** The cell below may take up to 4-5 minutes to run
"""

## RUN BUT DO NOT MODIFY ANY OF THIS CODE
!apt install libkrb5-dev
!wget https://downloads.apache.org/spark/spark-3.1.2/spark-3.1.2-bin-hadoop3.2.tgz
!tar xf spark-3.1.2-bin-hadoop3.2.tgz
!pip install findspark
!pip install sparkmagic
!pip install pyspark
! pip install pyspark --user
! pip install seaborn --user
! pip install plotly --user
! pip install imageio --user
! pip install folium --user

## RUN BUT DO NOT MODIFY ANY OF THIS CODE
from pyspark.sql import SparkSession
from pyspark.sql.types import *
import pyspark.sql.functions as F

import os

spark = SparkSession.builder.appName('ml-hw4').getOrCreate()

# Commented out IPython magic to ensure Python compatibility.
# %load_ext sparkmagic.magics

## RUN BUT DO NOT MODIFY ANY OF THIS CODE

# Graph section
import networkx as nx
# SQLite RDBMS
import sqlite3
# Parallel processing
# import swifter
import pandas as pd
# NoSQL DB
from pymongo import MongoClient
from pymongo.errors import DuplicateKeyError, OperationFailure

import os
os.environ['SPARK_HOME'] = '/content/spark-3.1.2-bin-hadoop3.2'
os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-8-openjdk-amd64"
import pyspark
from pyspark.sql import SQLContext

## RUN BUT DO NOT MODIFY ANY OF THIS CODE
try:
    if(spark == None):
        spark = SparkSession.builder.appName('Initial').getOrCreate()
        sqlContext=SQLContext(spark)
except NameError:
    spark = SparkSession.builder.appName('Initial').getOrCreate()
    sqlContext=SQLContext(spark)

"""#### **2.1** Initializing Spark Data

We have the spark setup ready. Now we need the data for our ML algorithms. We will use the data you processed in Section 1 but in Spark. 

Read in the ```combined_df``` that you created in 1.4.3(a) into a Spark dataframe (`sdf`) and name the SDF as `data_sdf`. Make sure to set the inferSchema flag to True when you do this so that the columns are the correct datatypes and not all strings.
"""

#TODO: Read in the combined_df dataframe into a Spark Dataframe(.sdf)
data_sdf = spark.createDataFrame(combined_df)

"""Print out the Dataframe Schema and verify the datatypes. If you did everything correctly so far, the schema should be:
```
root
 |-- lat: double (nullable = true)
 |-- long: double (nullable = true)
 |-- construction_year: double (nullable = true)
 |-- minimum_nights: double (nullable = true)
 |-- number_of_reviews: double (nullable = true)
 |-- reviews_per_month: double (nullable = true)
 |-- price: double (nullable = true)
 |-- total_host_listings: double (nullable = true)
 |-- availability_365: double (nullable = true)
 |-- cancellation_factor: long (nullable = true)
 |-- host_identity_verified_unconfirmed: long (nullable = true)
 |-- host_identity_verified_verified: long (nullable = true)
 |-- borough_Bronx: long (nullable = true)
 |-- borough_Brooklyn: long (nullable = true)
 |-- borough_Manhattan: long (nullable = true)
 |-- borough_Queens: long (nullable = true)
 |-- borough_Staten Island: long (nullable = true)
 |-- instant_bookable_False: long (nullable = true)
 |-- instant_bookable_True: long (nullable = true)
 |-- room_type_Entire home/apt: long (nullable = true)
 |-- room_type_Hotel room: long (nullable = true)
 |-- room_type_Private room: long (nullable = true)
 |-- room_type_Shared room: long (nullable = true)
 |-- rating_boolean: double (nullable = true)
 ```
"""

# TO-DO: Verify that the schema of your Spark dataframe matches the above
data_sdf.printSchema()

"""Great job, we have the processed data now. For Spark ML, we need to create a feature column which has all features concatenated and a single column for labels, which we already have!
We will use `VectorAssembler()` to create a feature vector from all categorical and numerical features and we call the final vector as ‚Äúfeatures‚Äù.
First list all columns in the data and store it in a list named all_columns.
"""

# TO-DO: store all column name in the data_sdf in a list called `all_columns`
all_columns = data_sdf.columns

"""Create a list of column(s) which you don't want to include in your features. Name this list `drop_columns`."""

# TO-DO: Create `drop_columns`
drop_columns = ("rating_boolean")

"""Now using `drop_columns` or otherwise, create a list called `columns_to_use` that contains the names of all other columns that would be used as features for the ML models."""

# TO-DO: Create `columns_to_use` list
columns_to_use = [x for x in all_columns if x not in drop_columns]

# Grader (2 points)
grader.grade(test_case_id = 'check_columns_to_use', answer = columns_to_use)

"""Create a VectorAssembler object with columns you want to use. Name your output column as `features` (i.e. they are the features you wanna use later)."""

# TO-DO: Import required library and create VectorAssembler object (to be used later)
from pyspark.ml.linalg import Vectors
from pyspark.ml.feature import VectorAssembler

assembler = VectorAssembler(inputCols=columns_to_use, outputCol="features")

"""## **2.2** Create Pipeline

Now we will create a pipeline. For this data, we just need a single stage with the assembler, but you could have other stages before that where you perform operations on the data like converting categorical strings in the features to numeric values, or do feature scaling operations.

In this step, we will create a pipeline with a single stage ‚Äî the assembler. Fit the pipeline to your data and create the transformed dataframe and name it `modified_data_sdf`.
"""

# TO-DO: Import required libraries
from pyspark.ml import Pipeline

# TO-DO: Define a pipeline object
pipeline = Pipeline(stages=[assembler])
pipeline_model = pipeline.fit(data_sdf)

# TO-DO: Fit and transform the pipeline on the data and store the transformed sdf as `modified_data_sdf`
modified_data_sdf = pipeline_model.transform(data_sdf)

"""Now that we have the data in the format we need, we will create our train and test sets.

Conduct a train-test split where 80% of the data is assigned to the training set while the remaining 20% is assigned to the testing set.

**Clarifications:**
- Name these `train_sdf` and `test_sdf` respectively.
- Set the variable `random_seed` to 42 and then add the argument `seed = random_seed` in the function to fix the random state in order to ensure consistency with our results.
"""

# TO-DO: Assign appropriate value to the random_seed variable
random_seed = 42

# TO-DO: Do 80/20 train-test split with seed = random_seed and store them as "train_sdf" and "test_sdf"
train_sdf, test_sdf = modified_data_sdf.randomSplit([0.8, 0.2], seed=random_seed)

# Grader (3 points)
grader.grade(test_case_id = 'check_train_test_split_spark', answer = (train_sdf.count(), test_sdf.count(), random_seed))

"""***Manual Grading (1 point):*** The sections 2.3, 2.4 and 2.5 have a manual grading component of *1 point*. We will be manually going through your modeling structure. There will be negative points (penalties) for grave mistakes in modeling (Example: Using test data for training, not calculating the predictions on appropriate data sets, etc.)

## **2.3** LASSO Regularized Logistic Regression

**Logistic Regression Using SparkML**

Time to do the cool stuff! Let's train a Logistic Regression model to our data and try to predict whether the rating will be `high` or `low`.

This time, we will use "Big" data tools to help us build a Logistic Regression model for binary classification.

Look up the documentation online and try to understand how to implement this.

**Model 1: Train a Model without any Regularization.**
"""

# TO-DO: Import required library for Logistic Regression
from pyspark.ml.classification import LogisticRegression

# TO-DO: Instantiate and fit Logistic Regression model to training data
logit = LogisticRegression(featuresCol = "features", labelCol = "rating_boolean", maxIter = 10)
logit = logit.fit(train_sdf);

"""Calculate the training accuracy using the model's summary and store it in a variable named `train_accuracy`"""

# TO-DO: Get training accuracy and store it as `train_accuracy`
from pyspark.ml.evaluation import BinaryClassificationEvaluator

evaluator = BinaryClassificationEvaluator(rawPredictionCol='prediction', labelCol='rating_boolean')

predict_train = logit.transform(train_sdf)

# train_accuracy = evaluator.evaluate(predict_train)
train_accuracy = predict_train.filter(predict_train.rating_boolean == predict_train.prediction).count() / float(predict_train.count())

"""Now, find out how good the model actually is and see if it overfits to the training data.

Predict the label `rating_boolean` for your test data and store them as `predictions` _(Hint: it is called 'transform' in Spark ML)_
"""

# TO-DO: Make predictions on testing set and store it as `predictions`
predictions = logit.transform(test_sdf)

predictions.first()

"""**Confusion Matrix**(Binary Classification): \\
A confusion matrix is used to consolidate the predictive performance of a model into a single table. In a binary classification scenario, it looks like this: \\
![cm.jpeg](data:image/jpeg;base64,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4o/+A1P/AJYfiP8A8Kw8f/8ARNPiB/4Rup//ACPR/wAKw8f/APRNPiB/4Rup/wDyPX7cYNGDR/q5hP5pf+S//Ih/xGriH/nxR/8AAan/AMsPxH/4Vh4//wCiafED/wAI3U//AJHo/wCFYeP/APomnxA/8I3U/wD5Hr9uMGjBo/1cwn80v/Jf/kQ/4jVxD/z4o/8AgNT/AOWH4j/8Kw8f/wDRNPiB/wCEbqf/AMj0f8Kw8f8A/RNPiB/4Rup//I9ftxg0YNH+rmE/ml/5L/8AIh/xGriH/nxR/wDAan/yw/Ef/hWHj/8A6Jp8QP8AwjdT/wDkej/hWHj/AP6Jp8QP/CN1P/5Hr9uMGjBo/wBXMJ/NL/yX/wCRD/iNXEP/AD4o/wDgNT/5YfiP/wAKw8f/APRNPiB/4Rup/wDyPR/wrDx//wBE0+IH/hG6n/8AI9ftxg0YNH+rmE/ml/5L/wDIh/xGriH/AJ8Uf/Aan/yw/Ef/AIVh4/8A+iafED/wjdT/APkej/hWHj//AKJp8QP/AAjdT/8Akev24waMGj/VzCfzS/8AJf8A5EP+I1cQ/wDPij/4DU/+WH5TfshfD7xlpf7TngDUdR8EeLdH021nvnub7UvDl9aW8IbT7pF3SSxBV3M6gfN1Nfqo6t/CefXHSkH3TgeXjr3pSwh6/NnrXvYTCQwdL2VM/JuIuIMTxLj3mOMjGMnGMfdvy+7/AIpSJ6KKK6z5wKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Z) \\
Given the confusion matrix, we can calculate accuracy, precision, recall, F1 score and other metrics. For example, the formula for accuraccy would be: \\


> Accuracy = $\frac{TP + TN}{TP + FP + TN + FN}$

Evaluate the performance using the Confusion Matrix using `MulticlassMetrics` object in the Spark ML Regression library. Store the Confusion Matrix as an numpy array named  ```cm```. \\
**Note:** It might be useful to look at the documentation [here](https://spark.apache.org/docs/latest/mllib-evaluation-metrics.html) and [here](https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.mllib.evaluation.MulticlassMetrics.html) \\
For this section, you can ignore any warning messages that may appear.
"""

predictions.printSchema()

predictions.first()

# TO-DO: Import required libraries
from pyspark.mllib.evaluation import MulticlassMetrics

# TO-DO: Select appropriate columns to use MulticlassMetrics
rdd = predictions['prediction', 'rating_boolean'].rdd

# TO-DO: Instantiate metrics objects
metrics = MulticlassMetrics(rdd)

# TO-DO: Create confusion matrix and store it as a numpy array named "cm"
cm = metrics.confusionMatrix().toArray()

cm

"""Calculate the accuracy from the Confusion Matrix obtained above, and store it in a variable named ```test_accuracy```."""

# TO-DO: Calculate the test accuracy from the Confusion Matrix obtained and store it as "test_accuracy"

# test_accuracy = predictions.filter(predictions.rating_boolean == predictions.prediction).count() / float(predictions.count())
# test_accuracy = (cm[0][0] + cm[1][1])/(cm[0][0] + cm[0][1] + cm[1][0] + cm[1][1])
test_accuracy = metrics.accuracy

# Grader (6 points)
grader.grade(test_case_id = 'check_logistic_without_reg', answer = (train_accuracy, test_accuracy, cm))

"""**Model 2: Train a Model with Regularization.**

Now, we will add regularization to avoid overfitting. 

Play around with different regularization parameters - try out LASSO (L1), Ridge (L2) and elastic net (combination of L1 and L2) and different regularization hyperparameters when initializing 3 different regularized logistic regression models. 

Compare these with each other and the non regularized regression done above.

Make sure to evaluate the performance on test data using the same methodology as above (calculating Confusion Matrix and then accuracy).
"""

# TO-DO: Instantiate LASSO/L1 regularized model as "l1_model"
l1_model = LogisticRegression(regParam = 0.1, elasticNetParam = 1, featuresCol = "features", labelCol = "rating_boolean", maxIter = 10)

# TO-DO: Fit and Transform "l1_model"
lasso_fit = l1_model.fit(train_sdf)
pred_lasso_test = lasso_fit.transform(test_sdf)

# TO-DO: Obtain Confusion matrix and then calculate test accuracy as done in previous section. 
rdd = pred_lasso_test['prediction', 'rating_boolean'].rdd
metrics = MulticlassMetrics(rdd)


# TO-DO: Store the Confusion matrix(and convert it to numpy array) on test set as "cm_l1_reg" and the test accuracy as "l1_accuracy"
cm_l1_reg = metrics.confusionMatrix().toArray()
l1_accuracy = metrics.accuracy

# TO-DO: Instantiate Ridge/L2 regularized model as "l2_model" 
l2_model = LogisticRegression(regParam = 0.1, elasticNetParam = 1, featuresCol = "features", labelCol = "rating_boolean", maxIter = 10)

# TO-DO: Fit and Transform "l2_model"
lasso_fit = l2_model.fit(train_sdf)
pred_lasso_test = lasso_fit.transform(test_sdf)

# TO-DO: Obtain Confusion matrix and then calculate test accuracy as done in previous section
rdd = pred_lasso_test['prediction', 'rating_boolean'].rdd
metrics = MulticlassMetrics(rdd)

# TO-DO: Store the Confusion matrix(and convert it to numpy array) on test set as `cm_l2_reg` and the test accuracy as `l2_accuracy`
cm_l2_reg = metrics.confusionMatrix().toArray()
l2_accuracy = metrics.accuracy

# TO-DO: Instantiate Elastic model with your choice of parameters as `elastic_model`
elastic_model = LogisticRegression(regParam = 0.1, elasticNetParam = 0.5, featuresCol = "features", labelCol = "rating_boolean", maxIter = 10)

# TO-DO: Fit and Transform `elastic_model`
elastic_fit = elastic_model.fit(train_sdf)
pred_elastic_test = elastic_fit.transform(test_sdf)

# TO-DO: Obtain Confusion matrix and then calculate test accuracy as done in previous section
rdd = pred_elastic_test['prediction', 'rating_boolean'].rdd
metrics = MulticlassMetrics(rdd)

# TO-DO: Store the Confusion matrix(and convert it to numpy array) on test set as `cm_elastic_reg` and the test accuracy as `elastic_accuracy`
cm_elastic_reg = metrics.confusionMatrix().toArray()
elastic_accuracy = metrics.accuracy

# Grader (6 points)
grader.grade(test_case_id = 'check_logistic_with_reg', answer = (l1_model.getElasticNetParam(), l1_model.getRegParam(), l1_accuracy, 
                                                                 l2_model.getElasticNetParam(), l2_model.getRegParam(), l2_accuracy, 
                                                                 elastic_model.getElasticNetParam(), elastic_model.getRegParam(), elastic_accuracy,
                                                                 cm_l1_reg, cm_l2_reg, cm_elastic_reg))

"""## **2.4** Random Forest

If you are looking to win Kaggle competitions, you definitely must know about Random Forests, Boosted Trees, etc. These ensemble methods generalize and work surprisingly well for a lot of classification problems and sometimes for regression problems (though regression trees are not the focus of this course).

Let's give it a go. Similar to what you did for the Logistic Regression model, create a Random Forest classifier model and name it `rf` and fit it to the training data. Call the fitted model `rf_model`

**Note1:** Set the `random_seed` to 42 and set the argument `seed = random_seed` while creating `rf` as a RandomForest object \\
**Note2:** Set `maxDepth` to a reasonable value lesser than 10
"""

# TO-DO: Import required libraries
from pyspark.ml.classification import RandomForestClassifier
from pyspark.ml.feature import StringIndexer

# TO-DO: Set random_seed to appropriate value
random_seed = 42

# TO-DO: Instantiate  RF Model and call it `rf`. Then fit it to training data
rf = RandomForestClassifier(featuresCol = "features", labelCol = "rating_boolean", seed = random_seed, numTrees = 10, maxDepth = 8)
rf = rf.fit(train_sdf)

"""This time, get predictions on both the training and testing sets and store them as `train_pred` and `test_pred` respectively"""

# TO-DO: Get predictions and save to "train_pred" and "test_pred" respectively
train_pred = rf.transform(train_sdf)
test_pred = rf.transform(test_sdf)

"""Evaluate using the accuracy metric again. Store the training accuracy in a variable named ```rf_train_accuracy``` and the test accuracy in a variable named ```rf_test_accuracy```"""

# TO-DO: Calculate the confusion matrices(and convert them to numpy arrays) for train set and test set
#        and call these `rf_train_cm` and `rf_test_cm` respectively

rdd_train = train_pred['prediction', 'rating_boolean'].rdd
metrics_train = MulticlassMetrics(rdd_train)
rf_train_cm = metrics_train.confusionMatrix().toArray()

rdd_test = test_pred['prediction', 'rating_boolean'].rdd
metrics_test = MulticlassMetrics(rdd_test)
rf_test_cm = metrics_test.confusionMatrix().toArray()

# TO-DO: Evaluate predictions using accuracy for both train and test
#        and call these `rf_train_accuracy` and `rf_test_accuracy` respectively
rf_train_accuracy = metrics_train.accuracy
rf_test_accuracy = metrics_test.accuracy

# Grader (6 points)
grader.grade(test_case_id = 'check_random_forest', answer = (rf_train_accuracy, train_pred.count(), 
                                                             rf_test_accuracy, test_pred.count(),
                                                             rf.getSeed(), rf_train_cm, rf_test_cm))

"""##**2.5** Dimensionality Reduction Using PCA

We will again use the powerful PCA to reduce the dimensions and project the data onto a lower dimensional space and fit a logistic regression on the new projected data.

You will need to choose a new appropriate value for the number of dimensions.

_Steps for this section:_
1.   Initialize a PCA model called `pca` with the appropriate number of dimensions
2.   Fit the model using the training data
3.   Get the PCA features from the trained model
4.   Instantiate a Logistic Regression model object called `lr_model`
5.   Train the Logistic Regression model using the PCA features
6.   Evaluate the performance on the training set and test set using the accuracy

Store the training accuracy in a variable named ```training_acc_pca``` and test accuracy in a variable named ```test_acc_pca```

**Hint**: Choose `k` for PCA using the explained variance plot you made earlier
"""

# TO-DO: Import required libraries
from pyspark.ml.feature import PCA

# TO-DO: Perform intermediate steps to address scale-variance in PCA
pca = PCA(k = 13, inputCol = "features", outputCol = "PcaFeatures")

# TO-DO: Instantiate PCA object as "pca" and then fit and transform. Make sure you make a reasonable choice for number of Principal components
pca_model = pca.fit(train_sdf)
x_train_pca = pca_model.transform(train_sdf)
x_test_pca = pca_model.transform(test_sdf)

# TO-DO: Instantiate Logistic Regression model and call the model object "lr_model"
lr_model = LogisticRegression(featuresCol = "features", labelCol = "rating_boolean")

# TO-DO: Fit Logistic Regression Model and get predictions
lr_model = lr_model.fit(x_train_pca)

# TO-DO: Calculate the confusion matrix(and convert it to numpy array) for train set and call it "pca_train_cm"
train_pred = lr_model.transform(x_train_pca)
rdd_train = train_pred['prediction', 'rating_boolean'].rdd
metrics_train = MulticlassMetrics(rdd_train)

pca_train_cm = metrics_train.confusionMatrix().toArray()

# TO-DO: Evaluate predictions on train using accuracy and call this "training_acc_pca"
training_acc_pca = metrics_train.accuracy

# TO-DO: Calculate the confusion matrix(and convert it to numpy array) for test set and call it "pca_test_cm"
test_pred = lr_model.transform(x_test_pca)
rdd_test = test_pred['prediction', 'rating_boolean'].rdd
metrics_test = MulticlassMetrics(rdd_test)

pca_test_cm = metrics_test.confusionMatrix().toArray()

# TO-DO: Evaluate predictions on test using accuracy and call this "test_acc_pca"
test_acc_pca = metrics_test.accuracy

# Grader (8 points)
grader.grade(test_case_id = 'check_pca', answer = (training_acc_pca, test_acc_pca,
                                                   pca.getK(), len(lr_model.coefficients),
                                                   pca_train_cm, pca_test_cm))

"""# Homework Submission

Good job! You have finished the homework :) The submission instructions are as follows:

* **Double check** that you have the correct PennID (all numbers) in the autograder. 

* **Triple check** that you have all plots shown in this Colab notebook before submitting (otherwise, your submission will be subjected to a **penalty of -5 points**).

*  Go to the "File" tab at the top left of the Colab UI, click "Download .ipynb" and then "Download .py".  **Rename** these two files to `homework4.ipynb` and `homework4.py` respectively and upload them to Gradescope.
  - <ins>**WAIT UNTIL THE GRADESCOPE AUTOGRADER FINISHES RUNNING!**</ins> If we have to manually upload this for you after the deadline, **we will apply a penalty of -5 points** (this stacks with any other penatlies)

* You must submit your notebook to receive credit. Post any issues with submission on Piazza and make sure to keep in mind the late day policy.

* After you submit your code, the teaching staff will manually grade your Colab notebook in order to validate the correctness of your code.
"""